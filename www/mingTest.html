<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>슬라이드 뷰어 (통합)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      min-height: 100vh;
      min-width: 100vw;
      overflow: hidden;
      font-family: 'Noto Sans KR', '맑은 고딕', 'Malgun Gothic', Arial, sans-serif;
      background: #f8f8f8;
    }
    body {
      background: #fff;
      width: 100vw;
      height: 100vh;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #app {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #tabbar-modal-overlay {
      display: none;
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.35);
      z-index: 9998;
    }
    #tabbar-container {
      width: auto;
      min-width: 340px;
      max-width: 90vw;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 8px 32px 0 rgba(0,0,0,0.18);
      z-index: 9999;
      padding: 32px 32px 18px 32px;
    }
    #tabbar-container.show-tabbar {
      display: flex;
    }
    #tabbar-container.show-tabbar ~ #tabbar-modal-overlay {
      display: block;
    }
    #tabbar {
      display: flex;
      gap: 8px;
      margin: 0 0 18px 0;
    }
    .tab {
      background: #f2f2f2;
      border: 1px solid #ccc;
      border-radius: 8px 8px 0 0;
      padding: 10px 22px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .tab.active {
      background: #222;
      color: #fff;
      border-bottom: 2px solid #222;
    }
    #searchbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    #searchInput {
      padding: 8px 14px;
      font-size: 1rem;
      border: 1px solid #bbb;
      border-radius: 6px;
      outline: none;
    }
    #searchBtn {
      padding: 8px 18px;
      font-size: 1rem;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #searchBtn:hover {
      background: #444;
    }
    .slide-container {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      pointer-events: auto;
      overflow: hidden;
    }
    .slide {
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
      pointer-events: auto;
    }
    .slide-img-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .slide-bg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      display: block;
    }
    .arrow {
      position: absolute;
      top: 50%;
      font-size: 3.5rem;
      color: #333;
      background: transparent;
      border: none;
      cursor: pointer;
      z-index: 2;
      padding: 0.1em 0.4em;
      border-radius: 0.5em;
      user-select: none;
      opacity: 0;
      transition: opacity 0.3s, box-shadow 0.2s, background 0.2s;
      pointer-events: auto;
      font-family: 'Arial Black', Arial, sans-serif;
      font-weight: bold;
      line-height: 1;
      box-shadow: 0 2px 8px 0 rgba(0,0,0,0.10);
      border: 1.5px solid #e0e0e0;
    }
    .arrow.left { left: 32px; }
    .arrow.right { right: 32px; }
    .arrow:hover, .arrow:focus, .arrow:active {
      opacity: 1;
      background: rgba(255,255,255,0.85);
    }
    .arrow:not(:hover):not(:focus):not(:active) {
      opacity: 0;
      background: transparent;
    }
    
    /* 텍스트 영역 스타일 */
    .textArea {
      position: absolute;
      color: #222;
      font-family: 'Noto Sans KR', '맑은 고딕', 'Malgun Gothic', Arial, sans-serif;
      font-weight: 900;
      line-height: 1.1;
      letter-spacing: 0.036em;
      z-index: 1;
      pointer-events: none;
    }
    .textArea p {
      margin: 0 0 0.2em 0;
      filter: drop-shadow(1px 0 white) drop-shadow(-1px 0 white)
        drop-shadow(0 1px white) drop-shadow(0 -1px white)
        drop-shadow(1px 1px white) drop-shadow(-1px -1px white)
        drop-shadow(1px -1px white) drop-shadow(-1px 1px white);
      user-select: none;
      cursor: default;
      opacity: 0;
      background: transparent;
      color: #222;
      text-align: left;
      width: auto;
      box-sizing: initial;
      word-break: normal;
      pointer-events: none;
      overflow: visible;
      /* 기본 상태는 transform 없음 */
      transform: translateY(0);
      transition: opacity 0.8s cubic-bezier(0.4,0,0.2,1), transform 0.8s cubic-bezier(0.4,0,0.2,1);
    }
    
    /* 첫 번째 문장용 특별 클래스 */
    .textArea p.first-line {
      transform: translateY(20px);
      transition: opacity 0.8s cubic-bezier(0.4,0,0.2,1), transform 0.8s cubic-bezier(0.4,0,0.2,1);
    }
    
    .textArea p.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .textArea p.done {
      opacity: 1;
      transform: translateY(0);
      transition: none; /* 이미 완료된 것은 transition 제거 */
    }
    
    /* 명사 버튼 스타일 */
    .noun-span {
      cursor: pointer;
      pointer-events: auto;
      color: #222;
      background: transparent;
      border: none;
      padding: 0;
      margin: 0;
      font: inherit;
      text-decoration: none;
    }
    .noun-span:hover {
    }
    
    @media (max-width: 900px) {
      #tabbar-container {
        min-width: 180px;
        max-width: 98vw;
        padding: 12px 6px 8px 6px;
        border-radius: 10px;
      }
      #tabbar {
        gap: 3px;
        margin: 0 0 8px 0;
      }
      .tab {
        padding: 5px 8px;
        font-size: 0.85rem;
        border-radius: 6px 6px 0 0;
      }
      #searchbox {
        gap: 3px;
        margin-bottom: 4px;
      }
      #searchInput {
        padding: 4px 7px;
        font-size: 0.85rem;
        border-radius: 4px;
      }
      #searchBtn {
        padding: 4px 10px;
        font-size: 0.85rem;
        border-radius: 4px;
      }
      #tabbar-close-btn {
        margin-top: 6px;
        padding: 4px 12px;
        font-size: 0.85rem;
        border-radius: 4px;
      }
    }
  </style>
</head>
<body>
  <div id="tabbar-container">
    <div id="tabbar">
      <button class="tab" data-label="BBC News">BBC News</button>
      <button class="tab" data-label="BBC Earth">BBC Earth</button>
      <button class="tab" data-label="NatGeo">NatGeo</button>
      <button class="tab" data-label="NatGeo Wild">NatGeo Wild</button>
      <button class="tab" data-label="NatGeo Kids">NatGeo Kids</button>
    </div>
    <div id="searchbox">
      <input type="text" id="searchInput" placeholder="검색어를 입력하세요" />
      <button id="searchBtn">Search</button>
    </div>
  </div>
  <div id="tabbar-modal-overlay"></div>
  <div id="app"></div>
  <script>
// 페이지별 텍스트 위치 설정 함수 - 쉽게 조정 가능
function getTextPosition(pageIndex) {
  const positions = {
    0: { left: 150, top: 980 }, // 1페이지 (0번 인덱스)
    1: { left: 150, top: 965 }  // 2페이지 (1번 인덱스)
  };
  return positions[pageIndex] || { left: 120, top: 700 };
}

// Model - 원본 사이트와 동일한 텍스트 위치로 업데이트
const slides = [
  {
    bg: '../assets/img/02.webp',
    text: [
      'What can you see',
      'when you look up at the night sky?',
      'Countless stars twinkle',
      'in the sky when the Sun sleeps.'
    ],
    textPos: getTextPosition(0)
  },
  {
    bg: '../assets/img/03.webp',
    text: [
      'The night sky, a world filled with',
      'stars, is called the universe.',
      'So, how did the universe come',
      'to be?'
    ],
    textPos: getTextPosition(1)
  }
];

let current = 0;
let textAnimated = [false, false]; // 각 페이지별 애니메이션 여부

// 커스텀 팝업 함수(laypop)
function laypop(message) {
  // 기존 alert 대신 tabbar 모달만 보이게 (팝업 제거)
  const tabbar = document.getElementById('tabbar-container');
  const overlay = document.getElementById('tabbar-modal-overlay');
  if (tabbar) tabbar.classList.add('show-tabbar');
  if (overlay) overlay.style.display = 'block';
  // inputbox에 클릭한 단어 넣기
  const searchInput = document.getElementById('searchInput');
  if (searchInput) searchInput.value = message;
  // tabbar가 열릴 때마다 첫 번째 탭(BBC News) active
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => tab.classList.remove('active'));
  if (tabs[0]) tabs[0].classList.add('active');
}

function makeNounSpan(word) {
  const span = document.createElement('span');
  span.textContent = word;
  span.className = 'noun-span';
  span.addEventListener('click', function(e) {
    e.stopPropagation();
    laypop(word);
  });
  return span;
}

function renderSlide(idx) {
  const slide = slides[idx];
  const app = document.getElementById('app');
  app.innerHTML = '';

  // 슬라이드 컨테이너
  const container = document.createElement('div');
  container.className = 'slide-container';

  // 왼쪽 화살표
  const leftArrow = document.createElement('button');
  leftArrow.className = 'arrow left';
  leftArrow.innerHTML = '&#60;';
  leftArrow.tabIndex = -1;
  leftArrow.addEventListener('click', prevSlide);
  container.appendChild(leftArrow);

  // 이미지+텍스트 래퍼
  const imgWrapper = document.createElement('div');
  imgWrapper.className = 'slide-img-wrapper';

  // 슬라이드(배경)
  const img = document.createElement('img');
  img.className = 'slide-bg';
  img.src = slide.bg;
  img.alt = 'slide';
  imgWrapper.appendChild(img);

  // 텍스트 영역
  const textArea = document.createElement('div');
  textArea.className = 'textArea';

  // 각 줄별로 명사에만 클릭 이벤트 적용
  slide.text.forEach((line, i) => {
    const p = document.createElement('p');
    
    // 첫 번째 문장에만 특별한 클래스 추가
    if (i === 0) {
      p.classList.add('first-line');
    }
    
    // 1페이지(0)와 2페이지(1)별로 명사 위치 다르게 처리
    if (idx === 0) {
      if (i === 1) {
        const before = 'when you look up at the night ';
        const noun = 'sky';
        const after = '?';
        p.appendChild(document.createTextNode(before));
        p.appendChild(makeNounSpan(noun));
        p.appendChild(document.createTextNode(after));
      } else if (i === 2) {
        const before = 'Countless ';
        const noun = 'stars';
        const after = ' twinkle';
        p.appendChild(document.createTextNode(before));
        p.appendChild(makeNounSpan(noun));
        p.appendChild(document.createTextNode(after));
      } else if (i === 3) {
        const before = 'in the ';
        const noun1 = 'sky';
        const middle = ' when the ';
        const noun2 = 'Sun';
        const after = ' sleeps.';
        p.appendChild(document.createTextNode(before));
        p.appendChild(makeNounSpan(noun1));
        p.appendChild(document.createTextNode(middle));
        p.appendChild(makeNounSpan(noun2));
        p.appendChild(document.createTextNode(after));
      } else {
        p.textContent = line;
      }
    } else if (idx === 1) {
      // 2페이지 명사: "night sky", "world", "stars", "universe"
      if (i === 0) {
        // 'The night sky, a world filled with'
        const before1 = 'The ';
        const noun1 = 'night sky';
        const comma = ', a ';
        const noun2 = 'world';
        const after = ' filled with';
        p.appendChild(document.createTextNode(before1));
        p.appendChild(makeNounSpan(noun1));
        p.appendChild(document.createTextNode(comma));
        p.appendChild(makeNounSpan(noun2));
        p.appendChild(document.createTextNode(after));
      } else if (i === 1) {
        // 'stars, is called the universe.'
        const noun1 = 'stars';
        const middle = ', is called the ';
        const noun2 = 'universe';
        const after = '.';
        p.appendChild(makeNounSpan(noun1));
        p.appendChild(document.createTextNode(middle));
        p.appendChild(makeNounSpan(noun2));
        p.appendChild(document.createTextNode(after));
      } else if (i === 2) {
        // 'So, how did the universe come'
        const before = 'So, how did the ';
        const noun = 'universe';
        const after = ' come';
        p.appendChild(document.createTextNode(before));
        p.appendChild(makeNounSpan(noun));
        p.appendChild(document.createTextNode(after));
      } else {
        p.textContent = line;
      }
    } else {
      p.textContent = line;
    }
    textArea.appendChild(p);
  });
  imgWrapper.appendChild(textArea);
  container.appendChild(imgWrapper);

  // 오른쪽 화살표
  const rightArrow = document.createElement('button');
  rightArrow.className = 'arrow right';
  rightArrow.innerHTML = '&#62;';
  rightArrow.tabIndex = -1;
  rightArrow.addEventListener('click', nextSlide);
  container.appendChild(rightArrow);

  app.appendChild(container);

  // 텍스트 애니메이션
  if (textAnimated[idx]) {
    const ps = textArea.querySelectorAll('p');
    ps.forEach(p => p.classList.remove('visible'));
    ps.forEach(p => p.classList.add('done'));
  } else {
    animateText(textArea);
    textAnimated[idx] = true;
  }

  // 화살표 위치(top) 조정
  positionArrows(img, leftArrow, rightArrow);

  // 드래그/터치 이벤트
  addDragEvents(container, leftArrow, rightArrow);

  // 이미지 로드 후 텍스트 위치 조정
  img.onload = () => {
    positionArrows(img, leftArrow, rightArrow);
    // 이미지 로드 완료 후 약간의 지연을 두고 위치 조정
    setTimeout(() => {
      positionTextAreaToImage(img, textArea, slide.textPos);
      setTextFontSizeByImage(img, textArea);
    }, 50);
  };
  
  // 리사이즈 시 텍스트 위치/글자크기 조정
  const resizeHandler = () => {
    positionArrows(img, leftArrow, rightArrow);
    // 리사이즈 시에도 약간의 지연을 두고 재계산
    setTimeout(() => {
      positionTextAreaToImage(img, textArea, slide.textPos);
      setTextFontSizeByImage(img, textArea);
    }, 10);
  };
  window.removeEventListener('resize', resizeHandler);
  window.addEventListener('resize', resizeHandler);
  
  // 최초 렌더링 시에도 위치/글자크기 조정 시도 (이미지 캐시 등)
  setTimeout(() => {
    positionTextAreaToImage(img, textArea, slide.textPos);
    setTextFontSizeByImage(img, textArea);
  }, 100);
  
  // 추가로 이미지가 완전히 렌더링된 후 한 번 더 조정
  const checkAndAdjust = () => {
    if (img.naturalWidth > 0 && img.naturalHeight > 0) {
      positionTextAreaToImage(img, textArea, slide.textPos);
      setTextFontSizeByImage(img, textArea);
    } else {
      setTimeout(checkAndAdjust, 50);
    }
  };
  checkAndAdjust();
}

function animateText(textArea) {
  const ps = textArea.querySelectorAll('p');
  
  // 모든 요소 초기화
  ps.forEach(p => { 
    p.classList.remove('visible', 'done');
  });
  
  // 첫 번째 문장은 아래에서 위로 부드럽게 (400ms 후)
  if (ps[0]) {
    setTimeout(() => { 
      ps[0].classList.add('visible'); 
    }, 400);
  }
  
  // 나머지 문장들은 빠르게 페이드인 (첫 문장 시작 후 200ms 간격으로)
  for (let i = 1; i < ps.length; i++) {
    setTimeout(() => { 
      ps[i].classList.add('visible'); 
    }, 600 + (i - 1) * 200); // 첫 문장 200ms 후부터 시작
  }
}

function positionArrows(imgElem, leftArrow, rightArrow) {
  if (!imgElem || !leftArrow || !rightArrow) return;
  const imgRect = imgElem.getBoundingClientRect();
  const slideRect = imgElem.parentElement.getBoundingClientRect();
  leftArrow.style.top = (imgRect.top - slideRect.top + imgRect.height/2) + 'px';
  rightArrow.style.top = (imgRect.top - slideRect.top + imgRect.height/2) + 'px';
  leftArrow.style.transform = 'translateY(-50%)';
  rightArrow.style.transform = 'translateY(-50%)';
}

// 이미지의 실제 렌더링 크기를 기준으로 텍스트 위치를 정확히 계산
function positionTextAreaToImage(imgElem, textArea, pos) {
  if (!imgElem || !textArea) return;
  
  // 이미지의 자연 크기 (원본 크기)
  const naturalWidth = imgElem.naturalWidth;
  const naturalHeight = imgElem.naturalHeight;
  
  if (naturalWidth === 0 || naturalHeight === 0) {
    // 이미지가 아직 로드되지 않은 경우
    setTimeout(() => positionTextAreaToImage(imgElem, textArea, pos), 100);
    return;
  }
  
  // 이미지 요소의 실제 표시 크기 (CSS에 의해 결정된 크기)
  const imgRect = imgElem.getBoundingClientRect();
  const containerRect = imgElem.parentElement.getBoundingClientRect();
  
  // object-fit: contain 때문에 이미지가 비율을 유지하며 표시됨
  // 실제 표시되는 이미지의 크기 계산
  const containerAspect = containerRect.width / containerRect.height;
  const imageAspect = naturalWidth / naturalHeight;
  
  let displayWidth, displayHeight;
  let offsetX, offsetY;
  
  if (imageAspect > containerAspect) {
    // 이미지가 컨테이너보다 더 넓은 비율 - 너비에 맞춤
    displayWidth = containerRect.width;
    displayHeight = containerRect.width / imageAspect;
    offsetX = 0;
    offsetY = (containerRect.height - displayHeight) / 2;
  } else {
    // 이미지가 컨테이너보다 더 높은 비율 - 높이에 맞춤
    displayWidth = containerRect.height * imageAspect;
    displayHeight = containerRect.height;
    offsetX = (containerRect.width - displayWidth) / 2;
    offsetY = 0;
  }
  
  // 원본 이미지 크기 대비 현재 표시 크기의 비율
  const scale = displayWidth / naturalWidth; // 또는 displayHeight / naturalHeight (같은 값)
  
  // 원본 위치를 현재 스케일에 맞게 조정
  const scaledLeft = pos.left * scale;
  const scaledTop = pos.top * scale;
  
  // 컨테이너 기준 최종 위치
  const finalLeft = offsetX + scaledLeft;
  const finalTop = offsetY + scaledTop;
  
  textArea.style.left = finalLeft + 'px';
  textArea.style.top = finalTop + 'px';
  textArea.style.transform = 'none';
}

// 이미지 크기에 정확히 비례하여 폰트 크기 설정
function setTextFontSizeByImage(imgElem, textArea) {
  if (!imgElem || !textArea) return;
  
  const naturalWidth = imgElem.naturalWidth;
  const naturalHeight = imgElem.naturalHeight;
  
  if (naturalWidth === 0 || naturalHeight === 0) {
    // 이미지가 아직 로드되지 않은 경우
    setTimeout(() => setTextFontSizeByImage(imgElem, textArea), 100);
    return;
  }
  
  // 이미지 요소의 실제 표시 크기 계산
  const containerRect = imgElem.parentElement.getBoundingClientRect();
  const imageAspect = naturalWidth / naturalHeight;
  const containerAspect = containerRect.width / containerRect.height;
  
  let displayWidth, displayHeight;
  
  if (imageAspect > containerAspect) {
    displayWidth = containerRect.width;
    displayHeight = containerRect.width / imageAspect;
  } else {
    displayWidth = containerRect.height * imageAspect;
    displayHeight = containerRect.height;
  }
  
  // 원본 이미지 크기 대비 현재 표시 크기의 비율
  const scale = displayWidth / naturalWidth;
  
  // 원본 사이트 기준 폰트 크기를 한 단계 올림 (36px -> 42px)
  const baseFontSize = 42;
  
  // 스케일에 따른 폰트 크기 계산
  let fontSize = baseFontSize * scale;
  
  // 최소/최대 폰트 크기 제한 (범위도 한 단계씩 올림)
  fontSize = Math.max(10, Math.min(fontSize, 70));
  
  const ps = textArea.querySelectorAll('p');
  ps.forEach(p => {
    p.style.fontSize = fontSize + 'px';
  });
}

function prevSlide() {
  current = (current - 1 + slides.length) % slides.length;
  renderSlide(current);
}
function nextSlide() {
  current = (current + 1) % slides.length;
  renderSlide(current);
}

function addDragEvents(container, leftArrow, rightArrow) {
  let startX = null;
  let dragging = false;
  container.onmousedown = e => { startX = e.clientX; dragging = true; };
  container.onmousemove = e => { if (!dragging) return; };
  container.onmouseup = e => {
    if (!dragging) return;
    const diff = e.clientX - startX;
    if (diff > 60) leftArrow.click();
    else if (diff < -60) rightArrow.click();
    dragging = false;
    startX = null;
  };
  // 모바일 터치
  container.ontouchstart = e => { startX = e.touches[0].clientX; dragging = true; };
  container.ontouchmove = e => { if (!dragging) return; };
  container.ontouchend = e => {
    if (!dragging) return;
    const endX = e.changedTouches[0].clientX;
    const diff = endX - startX;
    if (diff > 60) leftArrow.click();
    else if (diff < -60) rightArrow.click();
    dragging = false;
    startX = null;
  };
}

// 첫 슬라이드 표시
window.onload = () => renderSlide(current);

// 탭바 및 검색 인풋 이벤트 처리
window.addEventListener('DOMContentLoaded', () => {
  const tabs = document.querySelectorAll('.tab');
  const searchInput = document.getElementById('searchInput');
  // 기본적으로 BBC News 탭 클릭 상태
  tabs.forEach(tab => tab.classList.remove('active'));
  if (tabs[0]) tabs[0].classList.add('active');
  // 탭 클릭 시 inputbox에 내용 넣는 기능 제거
  tabs.forEach(tab => {
    tab.addEventListener('click', function() {
      tabs.forEach(t => t.classList.remove('active'));
      this.classList.add('active');
    });
  });
  // Search 버튼 기능: 탭에 따라 유튜브 채널 주소로 새 창 띄우기
  document.getElementById('searchBtn').addEventListener('click', function() {
    const tabToChannel = {
      'BBC News': 'UC16niRr50-MSBwiO3YDb3RA',
      'BBC Earth': 'UCwmZiChSryoWQCZMIQezgTg',
      'NatGeo': 'UCpVm7bg6pXKo1Pr6k5kxG9A',
      'NatGeo Wild': 'UCDPk9MG2RexnOMGTD-YnSnA',
      'NatGeo Kids': 'UCXVCgDuD_QCkI7gTKU7-tpg'
    };
    const activeTab = document.querySelector('.tab.active');
    const tabLabel = activeTab ? activeTab.dataset.label : 'BBC News';
    const channelId = tabToChannel[tabLabel] || tabToChannel['BBC News'];
    const query = encodeURIComponent(searchInput.value);
    const url = `https://www.youtube.com/channel/${channelId}/search?query=${query}`;
    window.open(url, '_blank');
  });
  // 닫기 버튼 동적 추가
  const tabbar = document.getElementById('tabbar-container');
  if (tabbar && !document.getElementById('tabbar-close-btn')) {
    const closeBtn = document.createElement('button');
    closeBtn.id = 'tabbar-close-btn';
    closeBtn.textContent = 'close';
    closeBtn.style.marginTop = '12px';
    closeBtn.style.padding = '8px 24px';
    closeBtn.style.fontSize = '1rem';
    closeBtn.style.background = '#222';
    closeBtn.style.color = '#fff';
    closeBtn.style.border = 'none';
    closeBtn.style.borderRadius = '6px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.transition = 'background 0.2s';
    closeBtn.addEventListener('mouseover', () => closeBtn.style.background = '#444');
    closeBtn.addEventListener('mouseout', () => closeBtn.style.background = '#222');
    closeBtn.addEventListener('click', () => {
      tabbar.classList.remove('show-tabbar');
      const overlay = document.getElementById('tabbar-modal-overlay');
      if (overlay) overlay.style.display = 'none';
    });
    tabbar.appendChild(closeBtn);
  }
  // 오버레이 클릭 시 닫기
  const overlay = document.getElementById('tabbar-modal-overlay');
  if (overlay) {
    overlay.addEventListener('click', () => {
      if (tabbar) tabbar.classList.remove('show-tabbar');
      overlay.style.display = 'none';
    });
  }
});
  </script>
</body>
</html>